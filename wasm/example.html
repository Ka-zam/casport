<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cascadix WASM Example</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        h1 {
            color: #333;
            border-bottom: 2px solid #4CAF50;
            padding-bottom: 10px;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .input-group {
            margin-bottom: 15px;
        }
        label {
            display: inline-block;
            width: 200px;
            font-weight: bold;
        }
        input {
            width: 150px;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        button {
            background-color: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin-right: 10px;
        }
        button:hover {
            background-color: #45a049;
        }
        .results {
            margin-top: 20px;
            padding: 15px;
            background-color: #f9f9f9;
            border-left: 4px solid #4CAF50;
            font-family: monospace;
            white-space: pre-wrap;
        }
        .error {
            color: #d32f2f;
            border-left-color: #d32f2f;
        }
        select {
            width: 160px;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <h1>Cascadix WebAssembly Demo</h1>
    
    <div class="container">
        <h2>LC Filter Designer</h2>
        <div class="input-group">
            <label>Cutoff Frequency (GHz):</label>
            <input type="number" id="cutoff" value="1.0" step="0.1">
        </div>
        <div class="input-group">
            <label>System Impedance (Ω):</label>
            <input type="number" id="z0" value="50" step="1">
        </div>
        <div class="input-group">
            <label>Test Frequency (GHz):</label>
            <input type="number" id="testFreq" value="0.5" step="0.1">
        </div>
        <button onclick="analyzeFilter()">Analyze Butterworth Filter</button>
        <div id="filterResults" class="results"></div>
    </div>

    <div class="container">
        <h2>Transmission Line Calculator</h2>
        <div class="input-group">
            <label>Line Length (mm):</label>
            <input type="number" id="lineLength" value="37.5" step="0.1">
        </div>
        <div class="input-group">
            <label>Characteristic Z (Ω):</label>
            <input type="number" id="lineZ0" value="50" step="1">
        </div>
        <div class="input-group">
            <label>Frequency (GHz):</label>
            <input type="number" id="lineFreq" value="2.0" step="0.1">
        </div>
        <div class="input-group">
            <label>Load Impedance (Ω):</label>
            <input type="number" id="loadZ" value="100" step="1">
        </div>
        <button onclick="analyzeTLine()">Analyze Transmission Line</button>
        <div id="tlineResults" class="results"></div>
    </div>

    <div class="container">
        <h2>Performance Benchmark</h2>
        <button onclick="runBenchmark()">Run Performance Benchmark</button>
        <div id="benchmarkResults" class="results"></div>
    </div>

    <div class="container">
        <h2>Custom Network Builder</h2>
        <div class="input-group">
            <label>Component Type:</label>
            <select id="compType">
                <option value="seriesR">Series Resistor</option>
                <option value="seriesL">Series Inductor</option>
                <option value="seriesC">Series Capacitor</option>
                <option value="shuntR">Shunt Resistor</option>
                <option value="shuntL">Shunt Inductor</option>
                <option value="shuntC">Shunt Capacitor</option>
            </select>
        </div>
        <div class="input-group">
            <label>Value (Ω, nH, or pF):</label>
            <input type="number" id="compValue" value="10" step="0.1">
        </div>
        <div class="input-group">
            <label>Frequency (GHz):</label>
            <input type="number" id="compFreq" value="1.0" step="0.1">
        </div>
        <button onclick="addComponent()">Add Component</button>
        <button onclick="clearNetwork()">Clear Network</button>
        <button onclick="analyzeNetwork()">Analyze Network</button>
        <div id="networkList" class="results"></div>
        <div id="networkResults" class="results"></div>
    </div>

    <script>
        let Module = null;
        let networkComponents = [];

        // Load the WASM module
        var script = document.createElement('script');
        script.src = 'cascadix_wasm.js';
        script.onload = function() {
            CascadixModule().then(function(module) {
                Module = module;
                console.log('Cascadix WASM module loaded successfully');
                document.getElementById('filterResults').textContent = 'Module loaded. Ready to analyze!';
            });
        };
        document.head.appendChild(script);

        function formatComplex(c) {
            const real = c.real.toFixed(3);
            const imag = c.imag.toFixed(3);
            if (Math.abs(c.imag) < 0.001) {
                return real;
            }
            return imag >= 0 ? `${real} + j${imag}` : `${real} - j${Math.abs(imag)}`;
        }

        function analyzeFilter() {
            if (!Module) {
                document.getElementById('filterResults').textContent = 'Module not loaded yet!';
                return;
            }

            try {
                const fc = parseFloat(document.getElementById('cutoff').value) * 1e9;
                const z0 = parseFloat(document.getElementById('z0').value);
                const testFreq = parseFloat(document.getElementById('testFreq').value) * 1e9;

                // Create Butterworth filter
                const filter = Module.butterworthLC3(fc, z0);

                // Recreate at test frequency for analysis
                const l_value = 0.7654 * z0 / (2 * Math.PI * fc);
                const c_value = 1.8478 / (z0 * 2 * Math.PI * fc);
                
                const l1 = Module.seriesInductor(l_value, testFreq);
                const c2 = Module.shuntCapacitor(c_value, testFreq);
                const l3 = Module.seriesInductor(l_value, testFreq);
                
                const testFilter = Module.cascade(Module.cascade(l1, c2), l3);

                // Get S-parameters
                const s = Module.getSParameters(testFilter, z0);
                
                // Calculate metrics
                const s11_mag = Math.sqrt(s.s11.real * s.s11.real + s.s11.imag * s.s11.imag);
                const s21_mag = Math.sqrt(s.s21.real * s.s21.real + s.s21.imag * s.s21.imag);
                const s11_db = 20 * Math.log10(s11_mag);
                const s21_db = 20 * Math.log10(s21_mag);
                const vswr = (1 + s11_mag) / (1 - s11_mag);

                // Get input impedance
                const z_in = Module.getInputImpedance(testFilter, {real: z0, imag: 0});

                let results = `3rd Order Butterworth Lowpass Filter
========================================
Design Parameters:
  Cutoff: ${(fc/1e9).toFixed(2)} GHz
  System Z: ${z0} Ω
  L1, L3: ${(l_value*1e9).toFixed(2)} nH
  C2: ${(c_value*1e12).toFixed(2)} pF

Analysis at ${(testFreq/1e9).toFixed(2)} GHz:
  S11: ${formatComplex(s.s11)} (${s11_db.toFixed(2)} dB)
  S21: ${formatComplex(s.s21)} (${s21_db.toFixed(2)} dB)
  S12: ${formatComplex(s.s12)}
  S22: ${formatComplex(s.s22)}
  
  VSWR: ${vswr.toFixed(2)}
  Input Z: ${formatComplex(z_in)} Ω`;

                document.getElementById('filterResults').textContent = results;
            } catch (error) {
                document.getElementById('filterResults').textContent = 'Error: ' + error.message;
                document.getElementById('filterResults').classList.add('error');
            }
        }

        function analyzeTLine() {
            if (!Module) {
                document.getElementById('tlineResults').textContent = 'Module not loaded yet!';
                return;
            }

            try {
                const length = parseFloat(document.getElementById('lineLength').value) / 1000; // Convert mm to m
                const z0 = parseFloat(document.getElementById('lineZ0').value);
                const freq = parseFloat(document.getElementById('lineFreq').value) * 1e9;
                const z_load = parseFloat(document.getElementById('loadZ').value);

                // Create transmission line
                const tline = Module.transmissionLine(length, z0, freq);

                // Get properties
                const z_in = Module.getInputImpedance(tline, {real: z_load, imag: 0});
                const s = Module.getSParameters(tline, z0);
                
                // Calculate electrical length
                const wavelength = 299792458 / freq; // c/f in meters
                const electrical_length = (length / wavelength) * 360;

                const s11_mag = Math.sqrt(s.s11.real * s.s11.real + s.s11.imag * s.s11.imag);
                const s21_mag = Math.sqrt(s.s21.real * s.s21.real + s.s21.imag * s.s21.imag);
                const s11_db = 20 * Math.log10(s11_mag);
                const s21_db = 20 * Math.log10(s21_mag);

                let results = `Transmission Line Analysis
========================================
Parameters:
  Length: ${(length*1000).toFixed(1)} mm
  Electrical Length: ${electrical_length.toFixed(1)}°
  Characteristic Z: ${z0} Ω
  Frequency: ${(freq/1e9).toFixed(2)} GHz
  Load Z: ${z_load} Ω

Results:
  Input Z: ${formatComplex(z_in)} Ω
  
S-Parameters (${z0}Ω reference):
  S11: ${s11_db.toFixed(2)} dB
  S21: ${s21_db.toFixed(2)} dB
  
ABCD Matrix:
  A: ${formatComplex(Module.getA(tline))}
  B: ${formatComplex(Module.getB(tline))}
  C: ${formatComplex(Module.getC(tline))}
  D: ${formatComplex(Module.getD(tline))}`;

                document.getElementById('tlineResults').textContent = results;
            } catch (error) {
                document.getElementById('tlineResults').textContent = 'Error: ' + error.message;
                document.getElementById('tlineResults').classList.add('error');
            }
        }

        function addComponent() {
            if (!Module) {
                document.getElementById('networkList').textContent = 'Module not loaded yet!';
                return;
            }

            const type = document.getElementById('compType').value;
            const value = parseFloat(document.getElementById('compValue').value);
            const freq = parseFloat(document.getElementById('compFreq').value) * 1e9;

            let component;
            let description;

            switch(type) {
                case 'seriesR':
                    component = Module.seriesResistor(value);
                    description = `Series R: ${value} Ω`;
                    break;
                case 'seriesL':
                    component = Module.seriesInductor(value * 1e-9, freq);
                    description = `Series L: ${value} nH @ ${(freq/1e9).toFixed(1)} GHz`;
                    break;
                case 'seriesC':
                    component = Module.seriesCapacitor(value * 1e-12, freq);
                    description = `Series C: ${value} pF @ ${(freq/1e9).toFixed(1)} GHz`;
                    break;
                case 'shuntR':
                    component = Module.shuntResistor(value);
                    description = `Shunt R: ${value} Ω`;
                    break;
                case 'shuntL':
                    component = Module.shuntInductor(value * 1e-9, freq);
                    description = `Shunt L: ${value} nH @ ${(freq/1e9).toFixed(1)} GHz`;
                    break;
                case 'shuntC':
                    component = Module.shuntCapacitor(value * 1e-12, freq);
                    description = `Shunt C: ${value} pF @ ${(freq/1e9).toFixed(1)} GHz`;
                    break;
            }

            networkComponents.push({comp: component, desc: description, freq: freq});
            updateNetworkList();
        }

        function clearNetwork() {
            networkComponents = [];
            updateNetworkList();
            document.getElementById('networkResults').textContent = '';
        }

        function updateNetworkList() {
            let list = 'Network Components:\n';
            networkComponents.forEach((item, index) => {
                list += `${index + 1}. ${item.desc}\n`;
            });
            document.getElementById('networkList').textContent = list || 'No components added yet';
        }

        function analyzeNetwork() {
            if (!Module || networkComponents.length === 0) {
                document.getElementById('networkResults').textContent = 'Add components first!';
                return;
            }

            try {
                // Cascade all components
                let network = networkComponents[0].comp;
                for (let i = 1; i < networkComponents.length; i++) {
                    network = Module.cascade(network, networkComponents[i].comp);
                }

                // Analyze at 50Ω
                const z0 = 50;
                const s = Module.getSParameters(network, z0);
                const z_in = Module.getInputImpedance(network, {real: z0, imag: 0});

                const s11_mag = Math.sqrt(s.s11.real * s.s11.real + s.s11.imag * s.s11.imag);
                const s21_mag = Math.sqrt(s.s21.real * s.s21.real + s.s21.imag * s.s21.imag);
                const s11_db = 20 * Math.log10(s11_mag);
                const s21_db = 20 * Math.log10(s21_mag);
                const vswr = (1 + s11_mag) / (1 - s11_mag);

                let results = `\nNetwork Analysis Results:
========================================
S-Parameters (50Ω reference):
  S11: ${s11_db.toFixed(2)} dB
  S21: ${s21_db.toFixed(2)} dB
  VSWR: ${vswr.toFixed(2)}
  
Input Impedance (50Ω load): ${formatComplex(z_in)} Ω

ABCD Matrix:
  A: ${formatComplex(Module.getA(network))}
  B: ${formatComplex(Module.getB(network))}
  C: ${formatComplex(Module.getC(network))}
  D: ${formatComplex(Module.getD(network))}`;

                document.getElementById('networkResults').textContent = results;
            } catch (error) {
                document.getElementById('networkResults').textContent = 'Error: ' + error.message;
                document.getElementById('networkResults').classList.add('error');
            }
        }

        function runBenchmark() {
            if (!Module) {
                document.getElementById('benchmarkResults').textContent = 'Module not loaded yet!';
                return;
            }

            let results = 'Running benchmarks...\n\n';
            document.getElementById('benchmarkResults').textContent = results;

            // Warm up
            let chain = Module.seriesResistor(0.0);
            for (let i = 0; i < 100; i++) {
                const r = Module.seriesResistor(1.0);
                chain = Module.cascade(chain, r);
            }

            // Benchmark 1: Cascade 1000 resistors
            let start = performance.now();
            chain = Module.seriesResistor(0.0);
            for (let i = 0; i < 1000; i++) {
                const r = Module.seriesResistor(1.0);
                chain = Module.cascade(chain, r);
            }
            let end = performance.now();
            results += `Cascaded 1000 resistors: ${(end - start).toFixed(2)} ms\n`;

            // Benchmark 2: Cascade 500 frequency-dependent components
            start = performance.now();
            chain = Module.seriesResistor(0.0);
            for (let i = 0; i < 500; i++) {
                const l = Module.seriesInductor(1e-9, 2.4e9);
                chain = Module.cascade(chain, l);
            }
            end = performance.now();
            results += `Cascaded 500 inductors: ${(end - start).toFixed(2)} ms\n`;

            // Benchmark 3: S-parameter calculations
            const testNetwork = Module.piAttenuator(6.0, 50.0);
            start = performance.now();
            for (let i = 0; i < 10000; i++) {
                const s = Module.getSParameters(testNetwork, 50.0);
            }
            end = performance.now();
            results += `10000 S-parameter calculations: ${(end - start).toFixed(2)} ms\n`;
            results += `Average: ${((end - start) / 10000 * 1000).toFixed(2)} μs per calculation\n\n`;

            // Benchmark 4: Complex filter
            start = performance.now();
            for (let i = 0; i < 1000; i++) {
                const filter = Module.butterworthLC3(1e9, 50.0);
            }
            end = performance.now();
            results += `1000 Butterworth filter creations: ${(end - start).toFixed(2)} ms\n`;

            // Performance comparison
            results += '\n📊 Performance Summary:\n';
            results += 'WebAssembly provides near-native speed for RF calculations!\n';
            results += 'Complex cascaded networks can be analyzed in real-time.';

            document.getElementById('benchmarkResults').textContent = results;
        }
    </script>
</body>
</html>